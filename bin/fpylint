#!/usr/bin/env python
# -*- coding: utf-8; mode: python; tab-width: 2; indent-tabs-mode: nil -*-
"""Emacs and Flymake compatible Pylint.

Originally based on epylint from the pylint distribution.
"""

import argparse
import collections
import itertools
import logging
import os
import pylint
import re
import subprocess
import sys

def SplitPackage(filename):
  """Given a filename, return a package and relative path."""
  full_path = os.path.realpath(filename)
  parent, child = os.path.split(full_path)
  while parent != '/' and os.path.exists(os.path.join(parent, '__init__.py')):
    child = os.path.join(os.path.basename(parent), child)
    parent = os.path.dirname(parent)
  return parent, child

def Lint(filename, indent=None):
  """Pylint the given file.

  When run from emacs we will be in the directory of a file, and
  passed its filename. If this file is part of a package and is trying
  to import other modules from within its own package or another
  package rooted in a directory below it, pylint will classify it as a
  failed import.

  To get around this, we traverse down the directory tree to find the
  root of the package this module is in. We then invoke pylint from
  this directory.

  Finally, we must correct the filenames in the output generated by
  pylint so Emacs doesn't become confused (it will expect just the
  original filename, while pylint may extend it with extra directories
  if we've traversed down the tree)
  """
  package_root, relative_path = SplitPackage(filename)

  # Create the pylint command line.
  cmd = [sys.executable,
         os.path.join(pylint.__path__[0], 'lint.py'),
         '--rcfile', os.path.expanduser('~/.pylintrc'),
         '-f', 'parseable',
         '-r', 'n',
         ]
  if indent is not None:
    cmd.append('--indent-string="%s"' % (' ' * indent,))
  cmd.append(relative_path)
  # Run pylint.
  process = subprocess.Popen(
      cmd, stdout=subprocess.PIPE, stderr=subprocess.PIPE, cwd=package_root)
  process.wait()

  # The parseable line format is '%(path)s:%(line)s: [%(sigle)s%(obj)s] %(msg)s'
  header_regex = re.compile(r'\[(?P<type>[ICRWE])(?P<remainder>.*?)\]')
  def RewriteHeader(match):
    """Alter to include 'Error' or 'Warning'"""
    if match.group('type') == 'E':
      replacement = 'Error'
    else:
      replacement = 'Warning'
    # replace as 'Warning (W0511, funcName): Warning Text'
    return '%s (%s%s):' % (replacement, match.group('type'), match.group('remainder'))

  prefix_re = re.compile(r'^%s:' % (relative_path,))
  prefix_replacement = filename + ':'
  def CleanLine(line):
    line = header_regex.sub(RewriteHeader, line, 1).rstrip()
    return prefix_re.sub(prefix_replacement, line, 1)

  def GetIndex(lines):
    return int(lines[0].split(':', 2)[1])

  def AddEntry(entries, entry):
    result = dict(entries)
    if entry:
      index = GetIndex(entry)
      result[index] = result.get(index, []) + ['\n'.join(entry)]
    return result

  new_entry_re = re.compile(r':\d+: (Warning|Error)')

  entries = {}
  entry = []
  for line in process.stdout:
    if line.startswith('**********'):
      continue
    line = CleanLine(line)
    if new_entry_re.search(line):
      entries = AddEntry(entries, entry)
      entry = []
    entry.append(line)
  else:
    entries = AddEntry(entries, entry)

  return process.returncode, entries

def PrintEntries(entries):
  for line_no in sorted(entries.keys()):
    for message in entries[line_no]:
      print message

def Run(argv):
  parser = argparse.ArgumentParser()
  parser.add_argument('--indent', type=int)
  args, filenames = parser.parse_known_args(argv)

  for filename in filenames:
    returncode, entries = Lint(filename, indent=args.indent)
    if returncode == 32:
      logging.warning('Error linting file %s', filename)
      sys.exit(1)
    PrintEntries(entries)

if __name__ == '__main__':
  Run(sys.argv[1:])
